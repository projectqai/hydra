// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,long_type_string
// @generated from protobuf file "world.proto" (package "world", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
// ---------------------------------------

/**
 * @generated from protobuf message world.Entity
 */
export interface Entity {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: optional string label = 2
     */
    label?: string;
    /**
     * @generated from protobuf field: optional world.ControllerRef controller = 3
     */
    controller?: ControllerRef;
    /**
     * @generated from protobuf field: optional world.Lifetime lifetime = 4
     */
    lifetime?: Lifetime;
    /**
     * @generated from protobuf field: optional world.Priority priority = 5
     */
    priority?: Priority;
    /**
     * @generated from protobuf field: optional world.GeoSpatialComponent geo = 11
     */
    geo?: GeoSpatialComponent;
    /**
     * @generated from protobuf field: optional world.SymbolComponent symbol = 12
     */
    symbol?: SymbolComponent;
    /**
     * @generated from protobuf field: optional world.CameraComponent camera = 15
     */
    camera?: CameraComponent;
    /**
     * @generated from protobuf field: optional world.DetectionComponent detection = 16
     */
    detection?: DetectionComponent;
    /**
     * @generated from protobuf field: optional world.BearingComponent bearing = 17
     */
    bearing?: BearingComponent;
    /**
     * @generated from protobuf field: optional world.LocationUncertaintyComponent locationUncertainty = 20
     */
    locationUncertainty?: LocationUncertaintyComponent;
    /**
     * @generated from protobuf field: optional world.TrackComponent track = 21
     */
    track?: TrackComponent;
    /**
     * @generated from protobuf field: optional world.LocatorComponent locator = 22
     */
    locator?: LocatorComponent;
    /**
     * @generated from protobuf field: optional world.TaskableComponent taskable = 23
     */
    taskable?: TaskableComponent;
}
/**
 * @generated from protobuf message world.ControllerRef
 */
export interface ControllerRef {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message world.Lifetime
 */
export interface Lifetime {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp from = 1
     */
    from?: Timestamp;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp until = 2
     */
    until?: Timestamp;
}
/**
 * @generated from protobuf message world.GeoSpatialComponent
 */
export interface GeoSpatialComponent {
    /**
     * @generated from protobuf field: double longitude = 1
     */
    longitude: number;
    /**
     * @generated from protobuf field: double latitude = 2
     */
    latitude: number;
    /**
     * @generated from protobuf field: double altitude = 3
     */
    altitude: number;
}
/**
 * @generated from protobuf message world.SymbolComponent
 */
export interface SymbolComponent {
    /**
     * @generated from protobuf field: string milStd2525C = 1
     */
    milStd2525C: string;
}
/**
 * @generated from protobuf message world.Camera
 */
export interface Camera {
    /**
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * @generated from protobuf field: string url = 2
     */
    url: string;
}
/**
 * @generated from protobuf message world.CameraComponent
 */
export interface CameraComponent {
    /**
     * @generated from protobuf field: repeated world.Camera cameras = 1
     */
    cameras: Camera[];
}
/**
 * @generated from protobuf message world.DetectionComponent
 */
export interface DetectionComponent {
    /**
     * @generated from protobuf field: optional string detectorEntityID = 1
     */
    detectorEntityID?: string;
    /**
     * @generated from protobuf field: optional string classification = 2
     */
    classification?: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp lastMeasured = 3
     */
    lastMeasured?: Timestamp;
}
/**
 * @generated from protobuf message world.BearingComponent
 */
export interface BearingComponent {
    /**
     * @generated from protobuf field: optional double azimuth = 1
     */
    azimuth?: number;
    /**
     * @generated from protobuf field: optional double elevation = 2
     */
    elevation?: number;
}
/**
 * @generated from protobuf message world.CovarianceMatrix
 */
export interface CovarianceMatrix {
    /**
     * @generated from protobuf field: optional double mxx = 1
     */
    mxx?: number;
    /**
     * @generated from protobuf field: optional double mxy = 2
     */
    mxy?: number;
    /**
     * @generated from protobuf field: optional double mxz = 3
     */
    mxz?: number;
    /**
     * @generated from protobuf field: optional double myy = 4
     */
    myy?: number;
    /**
     * @generated from protobuf field: optional double myz = 5
     */
    myz?: number;
    /**
     * @generated from protobuf field: optional double mzz = 6
     */
    mzz?: number;
}
/**
 * @generated from protobuf message world.LocationUncertaintyComponent
 */
export interface LocationUncertaintyComponent {
    /**
     * @generated from protobuf field: optional world.CovarianceMatrix positionEnuCov = 1
     */
    positionEnuCov?: CovarianceMatrix;
    /**
     * @generated from protobuf field: optional world.CovarianceMatrix velocityEnuCov = 2
     */
    velocityEnuCov?: CovarianceMatrix;
}
/**
 * @generated from protobuf message world.TrackComponent
 */
export interface TrackComponent {
}
/**
 * @generated from protobuf message world.LocatorComponent
 */
export interface LocatorComponent {
    /**
     * @generated from protobuf field: string locatedEntityID = 1
     */
    locatedEntityID: string;
}
/**
 * @generated from protobuf message world.TaskableContext
 */
export interface TaskableContext {
    /**
     * @generated from protobuf field: optional string entityId = 1
     */
    entityId?: string;
}
/**
 * @generated from protobuf message world.TaskableAssignee
 */
export interface TaskableAssignee {
    /**
     * @generated from protobuf field: optional string entityId = 1
     */
    entityId?: string;
}
/**
 * @generated from protobuf message world.TaskableComponent
 */
export interface TaskableComponent {
    /**
     * @generated from protobuf field: optional string reserved = 1
     */
    reserved?: string;
    /**
     * @generated from protobuf field: optional string label = 2
     */
    label?: string;
    /**
     * @generated from protobuf field: repeated world.TaskableContext context = 3
     */
    context: TaskableContext[];
    /**
     * @generated from protobuf field: repeated world.TaskableAssignee assignee = 4
     */
    assignee: TaskableAssignee[];
}
// ---------------------------------------------

/**
 * @generated from protobuf message world.Geometry
 */
export interface Geometry {
    /**
     * @generated from protobuf field: bytes wkb = 1
     */
    wkb: Uint8Array;
}
/**
 * @generated from protobuf message world.ListEntitiesRequest
 */
export interface ListEntitiesRequest {
    /**
     * @generated from protobuf field: optional world.Geometry geo = 2
     */
    geo?: Geometry;
    /**
     * @generated from protobuf field: optional world.TaskableContext taskableContext = 3
     */
    taskableContext?: TaskableContext;
    /**
     * @generated from protobuf field: optional world.TaskableAssignee TaskableAssignee = 4
     */
    taskableAssignee?: TaskableAssignee;
}
/**
 * @generated from protobuf message world.ListEntitiesResponse
 */
export interface ListEntitiesResponse {
    /**
     * @generated from protobuf field: repeated world.Entity entities = 1
     */
    entities: Entity[];
}
/**
 * @generated from protobuf message world.EntityChangeRequest
 */
export interface EntityChangeRequest {
    /**
     * @generated from protobuf field: repeated world.Entity changes = 1
     */
    changes: Entity[];
}
/**
 * @generated from protobuf message world.EntityChangeResponse
 */
export interface EntityChangeResponse {
    /**
     * @generated from protobuf field: bool accepted = 1
     */
    accepted: boolean;
    /**
     * @generated from protobuf field: string debug = 2
     */
    debug: string;
}
/**
 * @generated from protobuf message world.EntityChangeEvent
 */
export interface EntityChangeEvent {
    /**
     * @generated from protobuf field: world.Entity entity = 1
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: world.EntityChange t = 2
     */
    t: EntityChange;
}
/**
 * @generated from protobuf message world.GetEntityRequest
 */
export interface GetEntityRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message world.GetEntityResponse
 */
export interface GetEntityResponse {
    /**
     * @generated from protobuf field: world.Entity entity = 1
     */
    entity?: Entity;
}
/**
 * @generated from protobuf message world.ObserverRequest
 */
export interface ObserverRequest {
}
/**
 * @generated from protobuf message world.ObserverState
 */
export interface ObserverState {
    /**
     * @generated from protobuf field: world.Geometry geo = 1
     */
    geo?: Geometry;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp viewHistory = 2
     */
    viewHistory?: Timestamp;
}
/**
 * @generated from protobuf message world.RunTaskRequest
 */
export interface RunTaskRequest {
    /**
     * @generated from protobuf field: string entityId = 1
     */
    entityId: string;
}
/**
 * @generated from protobuf message world.RunTaskResponse
 */
export interface RunTaskResponse {
    /**
     * @generated from protobuf field: string executionId = 1
     */
    executionId: string;
    /**
     * @generated from protobuf field: world.TaskStatus status = 2
     */
    status: TaskStatus;
    /**
     * @generated from protobuf field: optional string humanReadableReason = 3
     */
    humanReadableReason?: string;
}
/**
 * @generated from protobuf enum world.Priority
 */
export enum Priority {
    /**
     * @generated from protobuf enum value: PriorityReserved0 = 0;
     */
    PriorityReserved0 = 0,
    /**
     * only send when there's enough bandwidth available
     * meta or auxiliary information where loss is tolerable
     *
     * @generated from protobuf enum value: PriorityLow = 1;
     */
    PriorityLow = 1,
    /**
     * send before low, but stay within bandwidth limits
     * this is typically used for detections and other urgent information
     *
     * @generated from protobuf enum value: PriorityHigh = 2;
     */
    PriorityHigh = 2,
    /**
     * Ignore bandwidth limit, send as hard as physically possible.
     * Use this only if absolutely sure you understand the operational consequences.
     * Doing this wrong can jeopardize missions
     *
     * @generated from protobuf enum value: PriorityBurst = 3;
     */
    PriorityBurst = 3
}
/**
 * @generated from protobuf enum world.EntityChange
 */
export enum EntityChange {
    /**
     * @generated from protobuf enum value: EntityChangeInvalid = 0;
     */
    EntityChangeInvalid = 0,
    /**
     * @generated from protobuf enum value: EntityChangeUpdated = 1;
     */
    EntityChangeUpdated = 1,
    /**
     * @generated from protobuf enum value: EntityChangeExpired = 2;
     */
    EntityChangeExpired = 2,
    /**
     * @generated from protobuf enum value: EntityChangeUnobserved = 3;
     */
    EntityChangeUnobserved = 3
}
/**
 * @generated from protobuf enum world.TaskStatus
 */
export enum TaskStatus {
    /**
     * @generated from protobuf enum value: TaskStatusInvalid = 0;
     */
    TaskStatusInvalid = 0,
    /**
     * @generated from protobuf enum value: TaskStatusRunning = 1;
     */
    TaskStatusRunning = 1,
    /**
     * @generated from protobuf enum value: TaskStatusCompleted = 2;
     */
    TaskStatusCompleted = 2,
    /**
     * @generated from protobuf enum value: TaskStatusFailed = 3;
     */
    TaskStatusFailed = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("world.Entity", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "controller", kind: "message", T: () => ControllerRef },
            { no: 4, name: "lifetime", kind: "message", T: () => Lifetime },
            { no: 5, name: "priority", kind: "enum", opt: true, T: () => ["world.Priority", Priority] },
            { no: 11, name: "geo", kind: "message", T: () => GeoSpatialComponent },
            { no: 12, name: "symbol", kind: "message", T: () => SymbolComponent },
            { no: 15, name: "camera", kind: "message", T: () => CameraComponent },
            { no: 16, name: "detection", kind: "message", T: () => DetectionComponent },
            { no: 17, name: "bearing", kind: "message", T: () => BearingComponent },
            { no: 20, name: "locationUncertainty", kind: "message", T: () => LocationUncertaintyComponent },
            { no: 21, name: "track", kind: "message", T: () => TrackComponent },
            { no: 22, name: "locator", kind: "message", T: () => LocatorComponent },
            { no: 23, name: "taskable", kind: "message", T: () => TaskableComponent }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* optional world.ControllerRef controller */ 3:
                    message.controller = ControllerRef.internalBinaryRead(reader, reader.uint32(), options, message.controller);
                    break;
                case /* optional world.Lifetime lifetime */ 4:
                    message.lifetime = Lifetime.internalBinaryRead(reader, reader.uint32(), options, message.lifetime);
                    break;
                case /* optional world.Priority priority */ 5:
                    message.priority = reader.int32();
                    break;
                case /* optional world.GeoSpatialComponent geo */ 11:
                    message.geo = GeoSpatialComponent.internalBinaryRead(reader, reader.uint32(), options, message.geo);
                    break;
                case /* optional world.SymbolComponent symbol */ 12:
                    message.symbol = SymbolComponent.internalBinaryRead(reader, reader.uint32(), options, message.symbol);
                    break;
                case /* optional world.CameraComponent camera */ 15:
                    message.camera = CameraComponent.internalBinaryRead(reader, reader.uint32(), options, message.camera);
                    break;
                case /* optional world.DetectionComponent detection */ 16:
                    message.detection = DetectionComponent.internalBinaryRead(reader, reader.uint32(), options, message.detection);
                    break;
                case /* optional world.BearingComponent bearing */ 17:
                    message.bearing = BearingComponent.internalBinaryRead(reader, reader.uint32(), options, message.bearing);
                    break;
                case /* optional world.LocationUncertaintyComponent locationUncertainty */ 20:
                    message.locationUncertainty = LocationUncertaintyComponent.internalBinaryRead(reader, reader.uint32(), options, message.locationUncertainty);
                    break;
                case /* optional world.TrackComponent track */ 21:
                    message.track = TrackComponent.internalBinaryRead(reader, reader.uint32(), options, message.track);
                    break;
                case /* optional world.LocatorComponent locator */ 22:
                    message.locator = LocatorComponent.internalBinaryRead(reader, reader.uint32(), options, message.locator);
                    break;
                case /* optional world.TaskableComponent taskable */ 23:
                    message.taskable = TaskableComponent.internalBinaryRead(reader, reader.uint32(), options, message.taskable);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* optional world.ControllerRef controller = 3; */
        if (message.controller)
            ControllerRef.internalBinaryWrite(message.controller, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional world.Lifetime lifetime = 4; */
        if (message.lifetime)
            Lifetime.internalBinaryWrite(message.lifetime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional world.Priority priority = 5; */
        if (message.priority !== undefined)
            writer.tag(5, WireType.Varint).int32(message.priority);
        /* optional world.GeoSpatialComponent geo = 11; */
        if (message.geo)
            GeoSpatialComponent.internalBinaryWrite(message.geo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional world.SymbolComponent symbol = 12; */
        if (message.symbol)
            SymbolComponent.internalBinaryWrite(message.symbol, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional world.CameraComponent camera = 15; */
        if (message.camera)
            CameraComponent.internalBinaryWrite(message.camera, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional world.DetectionComponent detection = 16; */
        if (message.detection)
            DetectionComponent.internalBinaryWrite(message.detection, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional world.BearingComponent bearing = 17; */
        if (message.bearing)
            BearingComponent.internalBinaryWrite(message.bearing, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional world.LocationUncertaintyComponent locationUncertainty = 20; */
        if (message.locationUncertainty)
            LocationUncertaintyComponent.internalBinaryWrite(message.locationUncertainty, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional world.TrackComponent track = 21; */
        if (message.track)
            TrackComponent.internalBinaryWrite(message.track, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* optional world.LocatorComponent locator = 22; */
        if (message.locator)
            LocatorComponent.internalBinaryWrite(message.locator, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional world.TaskableComponent taskable = 23; */
        if (message.taskable)
            TaskableComponent.internalBinaryWrite(message.taskable, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControllerRef$Type extends MessageType<ControllerRef> {
    constructor() {
        super("world.ControllerRef", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ControllerRef>): ControllerRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ControllerRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerRef): ControllerRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControllerRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.ControllerRef
 */
export const ControllerRef = new ControllerRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Lifetime$Type extends MessageType<Lifetime> {
    constructor() {
        super("world.Lifetime", [
            { no: 1, name: "from", kind: "message", T: () => Timestamp },
            { no: 2, name: "until", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Lifetime>): Lifetime {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Lifetime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Lifetime): Lifetime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp from */ 1:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* optional google.protobuf.Timestamp until */ 2:
                    message.until = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.until);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Lifetime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp from = 1; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp until = 2; */
        if (message.until)
            Timestamp.internalBinaryWrite(message.until, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.Lifetime
 */
export const Lifetime = new Lifetime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GeoSpatialComponent$Type extends MessageType<GeoSpatialComponent> {
    constructor() {
        super("world.GeoSpatialComponent", [
            { no: 1, name: "longitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "latitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "altitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<GeoSpatialComponent>): GeoSpatialComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.longitude = 0;
        message.latitude = 0;
        message.altitude = 0;
        if (value !== undefined)
            reflectionMergePartial<GeoSpatialComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GeoSpatialComponent): GeoSpatialComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double longitude */ 1:
                    message.longitude = reader.double();
                    break;
                case /* double latitude */ 2:
                    message.latitude = reader.double();
                    break;
                case /* double altitude */ 3:
                    message.altitude = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GeoSpatialComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double longitude = 1; */
        if (message.longitude !== 0)
            writer.tag(1, WireType.Bit64).double(message.longitude);
        /* double latitude = 2; */
        if (message.latitude !== 0)
            writer.tag(2, WireType.Bit64).double(message.latitude);
        /* double altitude = 3; */
        if (message.altitude !== 0)
            writer.tag(3, WireType.Bit64).double(message.altitude);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.GeoSpatialComponent
 */
export const GeoSpatialComponent = new GeoSpatialComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SymbolComponent$Type extends MessageType<SymbolComponent> {
    constructor() {
        super("world.SymbolComponent", [
            { no: 1, name: "milStd2525C", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SymbolComponent>): SymbolComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.milStd2525C = "";
        if (value !== undefined)
            reflectionMergePartial<SymbolComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SymbolComponent): SymbolComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string milStd2525C */ 1:
                    message.milStd2525C = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SymbolComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string milStd2525C = 1; */
        if (message.milStd2525C !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.milStd2525C);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SymbolComponent
 */
export const SymbolComponent = new SymbolComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Camera$Type extends MessageType<Camera> {
    constructor() {
        super("world.Camera", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Camera>): Camera {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<Camera>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Camera): Camera {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Camera, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.Camera
 */
export const Camera = new Camera$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraComponent$Type extends MessageType<CameraComponent> {
    constructor() {
        super("world.CameraComponent", [
            { no: 1, name: "cameras", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Camera }
        ]);
    }
    create(value?: PartialMessage<CameraComponent>): CameraComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cameras = [];
        if (value !== undefined)
            reflectionMergePartial<CameraComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraComponent): CameraComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.Camera cameras */ 1:
                    message.cameras.push(Camera.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.Camera cameras = 1; */
        for (let i = 0; i < message.cameras.length; i++)
            Camera.internalBinaryWrite(message.cameras[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.CameraComponent
 */
export const CameraComponent = new CameraComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DetectionComponent$Type extends MessageType<DetectionComponent> {
    constructor() {
        super("world.DetectionComponent", [
            { no: 1, name: "detectorEntityID", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classification", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lastMeasured", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<DetectionComponent>): DetectionComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DetectionComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DetectionComponent): DetectionComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string detectorEntityID */ 1:
                    message.detectorEntityID = reader.string();
                    break;
                case /* optional string classification */ 2:
                    message.classification = reader.string();
                    break;
                case /* optional google.protobuf.Timestamp lastMeasured */ 3:
                    message.lastMeasured = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastMeasured);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DetectionComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string detectorEntityID = 1; */
        if (message.detectorEntityID !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.detectorEntityID);
        /* optional string classification = 2; */
        if (message.classification !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.classification);
        /* optional google.protobuf.Timestamp lastMeasured = 3; */
        if (message.lastMeasured)
            Timestamp.internalBinaryWrite(message.lastMeasured, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.DetectionComponent
 */
export const DetectionComponent = new DetectionComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BearingComponent$Type extends MessageType<BearingComponent> {
    constructor() {
        super("world.BearingComponent", [
            { no: 1, name: "azimuth", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "elevation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<BearingComponent>): BearingComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BearingComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BearingComponent): BearingComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double azimuth */ 1:
                    message.azimuth = reader.double();
                    break;
                case /* optional double elevation */ 2:
                    message.elevation = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BearingComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double azimuth = 1; */
        if (message.azimuth !== undefined)
            writer.tag(1, WireType.Bit64).double(message.azimuth);
        /* optional double elevation = 2; */
        if (message.elevation !== undefined)
            writer.tag(2, WireType.Bit64).double(message.elevation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.BearingComponent
 */
export const BearingComponent = new BearingComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CovarianceMatrix$Type extends MessageType<CovarianceMatrix> {
    constructor() {
        super("world.CovarianceMatrix", [
            { no: 1, name: "mxx", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "mxy", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "mxz", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "myy", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "myz", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "mzz", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<CovarianceMatrix>): CovarianceMatrix {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CovarianceMatrix>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CovarianceMatrix): CovarianceMatrix {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double mxx */ 1:
                    message.mxx = reader.double();
                    break;
                case /* optional double mxy */ 2:
                    message.mxy = reader.double();
                    break;
                case /* optional double mxz */ 3:
                    message.mxz = reader.double();
                    break;
                case /* optional double myy */ 4:
                    message.myy = reader.double();
                    break;
                case /* optional double myz */ 5:
                    message.myz = reader.double();
                    break;
                case /* optional double mzz */ 6:
                    message.mzz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CovarianceMatrix, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double mxx = 1; */
        if (message.mxx !== undefined)
            writer.tag(1, WireType.Bit64).double(message.mxx);
        /* optional double mxy = 2; */
        if (message.mxy !== undefined)
            writer.tag(2, WireType.Bit64).double(message.mxy);
        /* optional double mxz = 3; */
        if (message.mxz !== undefined)
            writer.tag(3, WireType.Bit64).double(message.mxz);
        /* optional double myy = 4; */
        if (message.myy !== undefined)
            writer.tag(4, WireType.Bit64).double(message.myy);
        /* optional double myz = 5; */
        if (message.myz !== undefined)
            writer.tag(5, WireType.Bit64).double(message.myz);
        /* optional double mzz = 6; */
        if (message.mzz !== undefined)
            writer.tag(6, WireType.Bit64).double(message.mzz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.CovarianceMatrix
 */
export const CovarianceMatrix = new CovarianceMatrix$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationUncertaintyComponent$Type extends MessageType<LocationUncertaintyComponent> {
    constructor() {
        super("world.LocationUncertaintyComponent", [
            { no: 1, name: "positionEnuCov", kind: "message", T: () => CovarianceMatrix },
            { no: 2, name: "velocityEnuCov", kind: "message", T: () => CovarianceMatrix }
        ]);
    }
    create(value?: PartialMessage<LocationUncertaintyComponent>): LocationUncertaintyComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LocationUncertaintyComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationUncertaintyComponent): LocationUncertaintyComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional world.CovarianceMatrix positionEnuCov */ 1:
                    message.positionEnuCov = CovarianceMatrix.internalBinaryRead(reader, reader.uint32(), options, message.positionEnuCov);
                    break;
                case /* optional world.CovarianceMatrix velocityEnuCov */ 2:
                    message.velocityEnuCov = CovarianceMatrix.internalBinaryRead(reader, reader.uint32(), options, message.velocityEnuCov);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocationUncertaintyComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional world.CovarianceMatrix positionEnuCov = 1; */
        if (message.positionEnuCov)
            CovarianceMatrix.internalBinaryWrite(message.positionEnuCov, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional world.CovarianceMatrix velocityEnuCov = 2; */
        if (message.velocityEnuCov)
            CovarianceMatrix.internalBinaryWrite(message.velocityEnuCov, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.LocationUncertaintyComponent
 */
export const LocationUncertaintyComponent = new LocationUncertaintyComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackComponent$Type extends MessageType<TrackComponent> {
    constructor() {
        super("world.TrackComponent", []);
    }
    create(value?: PartialMessage<TrackComponent>): TrackComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackComponent): TrackComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.TrackComponent
 */
export const TrackComponent = new TrackComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocatorComponent$Type extends MessageType<LocatorComponent> {
    constructor() {
        super("world.LocatorComponent", [
            { no: 1, name: "locatedEntityID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LocatorComponent>): LocatorComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locatedEntityID = "";
        if (value !== undefined)
            reflectionMergePartial<LocatorComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocatorComponent): LocatorComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locatedEntityID */ 1:
                    message.locatedEntityID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocatorComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string locatedEntityID = 1; */
        if (message.locatedEntityID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locatedEntityID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.LocatorComponent
 */
export const LocatorComponent = new LocatorComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskableContext$Type extends MessageType<TaskableContext> {
    constructor() {
        super("world.TaskableContext", [
            { no: 1, name: "entityId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskableContext>): TaskableContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TaskableContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskableContext): TaskableContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string entityId */ 1:
                    message.entityId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskableContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string entityId = 1; */
        if (message.entityId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.TaskableContext
 */
export const TaskableContext = new TaskableContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskableAssignee$Type extends MessageType<TaskableAssignee> {
    constructor() {
        super("world.TaskableAssignee", [
            { no: 1, name: "entityId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskableAssignee>): TaskableAssignee {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TaskableAssignee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskableAssignee): TaskableAssignee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string entityId */ 1:
                    message.entityId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskableAssignee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string entityId = 1; */
        if (message.entityId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.TaskableAssignee
 */
export const TaskableAssignee = new TaskableAssignee$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskableComponent$Type extends MessageType<TaskableComponent> {
    constructor() {
        super("world.TaskableComponent", [
            { no: 1, name: "reserved", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "context", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskableContext },
            { no: 4, name: "assignee", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskableAssignee }
        ]);
    }
    create(value?: PartialMessage<TaskableComponent>): TaskableComponent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.context = [];
        message.assignee = [];
        if (value !== undefined)
            reflectionMergePartial<TaskableComponent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskableComponent): TaskableComponent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string reserved */ 1:
                    message.reserved = reader.string();
                    break;
                case /* optional string label */ 2:
                    message.label = reader.string();
                    break;
                case /* repeated world.TaskableContext context */ 3:
                    message.context.push(TaskableContext.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated world.TaskableAssignee assignee */ 4:
                    message.assignee.push(TaskableAssignee.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskableComponent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string reserved = 1; */
        if (message.reserved !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.reserved);
        /* optional string label = 2; */
        if (message.label !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* repeated world.TaskableContext context = 3; */
        for (let i = 0; i < message.context.length; i++)
            TaskableContext.internalBinaryWrite(message.context[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated world.TaskableAssignee assignee = 4; */
        for (let i = 0; i < message.assignee.length; i++)
            TaskableAssignee.internalBinaryWrite(message.assignee[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.TaskableComponent
 */
export const TaskableComponent = new TaskableComponent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Geometry$Type extends MessageType<Geometry> {
    constructor() {
        super("world.Geometry", [
            { no: 1, name: "wkb", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Geometry>): Geometry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.wkb = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Geometry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Geometry): Geometry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes wkb */ 1:
                    message.wkb = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Geometry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes wkb = 1; */
        if (message.wkb.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.wkb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.Geometry
 */
export const Geometry = new Geometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesRequest$Type extends MessageType<ListEntitiesRequest> {
    constructor() {
        super("world.ListEntitiesRequest", [
            { no: 2, name: "geo", kind: "message", T: () => Geometry },
            { no: 3, name: "taskableContext", kind: "message", T: () => TaskableContext },
            { no: 4, name: "TaskableAssignee", kind: "message", jsonName: "TaskableAssignee", T: () => TaskableAssignee }
        ]);
    }
    create(value?: PartialMessage<ListEntitiesRequest>): ListEntitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesRequest): ListEntitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional world.Geometry geo */ 2:
                    message.geo = Geometry.internalBinaryRead(reader, reader.uint32(), options, message.geo);
                    break;
                case /* optional world.TaskableContext taskableContext */ 3:
                    message.taskableContext = TaskableContext.internalBinaryRead(reader, reader.uint32(), options, message.taskableContext);
                    break;
                case /* optional world.TaskableAssignee TaskableAssignee */ 4:
                    message.taskableAssignee = TaskableAssignee.internalBinaryRead(reader, reader.uint32(), options, message.taskableAssignee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional world.Geometry geo = 2; */
        if (message.geo)
            Geometry.internalBinaryWrite(message.geo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional world.TaskableContext taskableContext = 3; */
        if (message.taskableContext)
            TaskableContext.internalBinaryWrite(message.taskableContext, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional world.TaskableAssignee TaskableAssignee = 4; */
        if (message.taskableAssignee)
            TaskableAssignee.internalBinaryWrite(message.taskableAssignee, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.ListEntitiesRequest
 */
export const ListEntitiesRequest = new ListEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesResponse$Type extends MessageType<ListEntitiesResponse> {
    constructor() {
        super("world.ListEntitiesResponse", [
            { no: 1, name: "entities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<ListEntitiesResponse>): ListEntitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesResponse): ListEntitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.Entity entities */ 1:
                    message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.Entity entities = 1; */
        for (let i = 0; i < message.entities.length; i++)
            Entity.internalBinaryWrite(message.entities[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.ListEntitiesResponse
 */
export const ListEntitiesResponse = new ListEntitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityChangeRequest$Type extends MessageType<EntityChangeRequest> {
    constructor() {
        super("world.EntityChangeRequest", [
            { no: 1, name: "changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<EntityChangeRequest>): EntityChangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.changes = [];
        if (value !== undefined)
            reflectionMergePartial<EntityChangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityChangeRequest): EntityChangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.Entity changes */ 1:
                    message.changes.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityChangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.Entity changes = 1; */
        for (let i = 0; i < message.changes.length; i++)
            Entity.internalBinaryWrite(message.changes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.EntityChangeRequest
 */
export const EntityChangeRequest = new EntityChangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityChangeResponse$Type extends MessageType<EntityChangeResponse> {
    constructor() {
        super("world.EntityChangeResponse", [
            { no: 1, name: "accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "debug", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntityChangeResponse>): EntityChangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accepted = false;
        message.debug = "";
        if (value !== undefined)
            reflectionMergePartial<EntityChangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityChangeResponse): EntityChangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool accepted */ 1:
                    message.accepted = reader.bool();
                    break;
                case /* string debug */ 2:
                    message.debug = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityChangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool accepted = 1; */
        if (message.accepted !== false)
            writer.tag(1, WireType.Varint).bool(message.accepted);
        /* string debug = 2; */
        if (message.debug !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.debug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.EntityChangeResponse
 */
export const EntityChangeResponse = new EntityChangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityChangeEvent$Type extends MessageType<EntityChangeEvent> {
    constructor() {
        super("world.EntityChangeEvent", [
            { no: 1, name: "entity", kind: "message", T: () => Entity },
            { no: 2, name: "t", kind: "enum", T: () => ["world.EntityChange", EntityChange] }
        ]);
    }
    create(value?: PartialMessage<EntityChangeEvent>): EntityChangeEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.t = 0;
        if (value !== undefined)
            reflectionMergePartial<EntityChangeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityChangeEvent): EntityChangeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* world.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* world.EntityChange t */ 2:
                    message.t = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityChangeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* world.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* world.EntityChange t = 2; */
        if (message.t !== 0)
            writer.tag(2, WireType.Varint).int32(message.t);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.EntityChangeEvent
 */
export const EntityChangeEvent = new EntityChangeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEntityRequest$Type extends MessageType<GetEntityRequest> {
    constructor() {
        super("world.GetEntityRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetEntityRequest>): GetEntityRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetEntityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEntityRequest): GetEntityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEntityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.GetEntityRequest
 */
export const GetEntityRequest = new GetEntityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEntityResponse$Type extends MessageType<GetEntityResponse> {
    constructor() {
        super("world.GetEntityResponse", [
            { no: 1, name: "entity", kind: "message", T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<GetEntityResponse>): GetEntityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEntityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEntityResponse): GetEntityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* world.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* world.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.GetEntityResponse
 */
export const GetEntityResponse = new GetEntityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObserverRequest$Type extends MessageType<ObserverRequest> {
    constructor() {
        super("world.ObserverRequest", []);
    }
    create(value?: PartialMessage<ObserverRequest>): ObserverRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ObserverRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObserverRequest): ObserverRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObserverRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.ObserverRequest
 */
export const ObserverRequest = new ObserverRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObserverState$Type extends MessageType<ObserverState> {
    constructor() {
        super("world.ObserverState", [
            { no: 1, name: "geo", kind: "message", T: () => Geometry },
            { no: 2, name: "viewHistory", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ObserverState>): ObserverState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ObserverState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObserverState): ObserverState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* world.Geometry geo */ 1:
                    message.geo = Geometry.internalBinaryRead(reader, reader.uint32(), options, message.geo);
                    break;
                case /* optional google.protobuf.Timestamp viewHistory */ 2:
                    message.viewHistory = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.viewHistory);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObserverState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* world.Geometry geo = 1; */
        if (message.geo)
            Geometry.internalBinaryWrite(message.geo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp viewHistory = 2; */
        if (message.viewHistory)
            Timestamp.internalBinaryWrite(message.viewHistory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.ObserverState
 */
export const ObserverState = new ObserverState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunTaskRequest$Type extends MessageType<RunTaskRequest> {
    constructor() {
        super("world.RunTaskRequest", [
            { no: 1, name: "entityId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunTaskRequest>): RunTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entityId = "";
        if (value !== undefined)
            reflectionMergePartial<RunTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunTaskRequest): RunTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entityId */ 1:
                    message.entityId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entityId = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RunTaskRequest
 */
export const RunTaskRequest = new RunTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunTaskResponse$Type extends MessageType<RunTaskResponse> {
    constructor() {
        super("world.RunTaskResponse", [
            { no: 1, name: "executionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["world.TaskStatus", TaskStatus] },
            { no: 3, name: "humanReadableReason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunTaskResponse>): RunTaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.executionId = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<RunTaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunTaskResponse): RunTaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string executionId */ 1:
                    message.executionId = reader.string();
                    break;
                case /* world.TaskStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* optional string humanReadableReason */ 3:
                    message.humanReadableReason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunTaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string executionId = 1; */
        if (message.executionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.executionId);
        /* world.TaskStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* optional string humanReadableReason = 3; */
        if (message.humanReadableReason !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.humanReadableReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RunTaskResponse
 */
export const RunTaskResponse = new RunTaskResponse$Type();
/**
 * @generated ServiceType for protobuf service world.WorldService
 */
export const WorldService = new ServiceType("world.WorldService", [
    { name: "ListEntities", options: {}, I: ListEntitiesRequest, O: ListEntitiesResponse },
    { name: "GetEntity", options: {}, I: GetEntityRequest, O: GetEntityResponse },
    { name: "WatchEntities", serverStreaming: true, options: {}, I: ListEntitiesRequest, O: EntityChangeEvent },
    { name: "Push", options: {}, I: EntityChangeRequest, O: EntityChangeResponse },
    { name: "Observe", serverStreaming: true, options: {}, I: ObserverRequest, O: ObserverState },
    { name: "RunTask", options: {}, I: RunTaskRequest, O: RunTaskResponse }
]);
